import torch
import torch.nn as nn
import torch.optim as optim
import numpy as np
import pandas as pd
import importlib.util
import sys


# --- NEW LSTM PREDICTOR CLASS ---
class PortfolioPredictorLSTM(nn.Module):
    def __init__(self, input_size, output_size, hidden_size=64, num_layers=2):
        super(PortfolioPredictorLSTM, self).__init__()
        self.hidden_size = hidden_size
        self.num_layers = num_layers

        # 1. LSTM Layer: Processes the sequence of features
        self.lstm = nn.LSTM(input_size, hidden_size, num_layers, batch_first=True)

        # 2. Fully Connected Layer: Maps the LSTM's final state to the output
        self.fc = nn.Linear(hidden_size, output_size)

    def forward(self, x):
        # Reshape input for LSTM: (batch_size, sequence_length, features)
        x = x.unsqueeze(1)  # x: (N_SAMPLES, 1, N_FEATURES)

        # Initialize hidden state and cell state
        h0 = torch.zeros(self.num_layers, x.size(0), self.hidden_size).to(x.device)
        c0 = torch.zeros(self.num_layers, x.size(0), self.hidden_size).to(x.device)
        
        # LSTM forward pass
        lstm_out, _ = self.lstm(x, (h0, c0))

        # Use output from last time step and map to output assets
        out = self.fc(lstm_out[:, -1, :])  # (N_SAMPLES, output_size)
        return out

# --- Import X_final and Y_final from yfinance data.py ---
# Since the filename has a space, we use importlib to import it as a module
spec = importlib.util.spec_from_file_location("yfinance_data", "yfinance data.py")
yfinance_data = importlib.util.module_from_spec(spec)
sys.modules["yfinance_data"] = yfinance_data
spec.loader.exec_module(yfinance_data)

# Extract the variables we need
try:
    X_final = yfinance_data.X_final
    Y_final = yfinance_data.Y_final
except AttributeError as e:
    raise ValueError(f"Failed to import X_final or Y_final from yfinance data.py. Error: {e}\n"
                    "Make sure yfinance data.py has been run successfully and X_final, Y_final are defined.")

# Validate the imported data
if X_final is None or Y_final is None:
    raise ValueError("X_final or Y_final is None. Check yfinance data.py execution.")
if X_final.empty or Y_final.empty:
    raise ValueError("X_final or Y_final is empty. Check data processing in yfinance data.py.")

print(f"\n--- Data Imported Successfully ---")
print(f"X_final shape: {X_final.shape}")
print(f"Y_final shape: {Y_final.shape}")

# --- 1. PyTorch Data Conversion ---

# Convert DataFrames to NumPy arrays, then to PyTorch tensors
X_np = X_final.values.astype(np.float32)
Y_np = Y_final.values.astype(np.float32)

# Ensure X and Y have the same number of rows (samples)
if X_np.shape[0] != Y_np.shape[0]:
    raise ValueError(f"X_final and Y_final must have the same number of rows. "
                    f"X_final: {X_np.shape[0]}, Y_final: {Y_np.shape[0]}")

X_tensor = torch.tensor(X_np, dtype=torch.float32)
Y_tensor = torch.tensor(Y_np, dtype=torch.float32)

# Define shapes for the network
N_FEATURES = X_tensor.shape[1]  # Number of input signals (e.g., 5)
N_ASSETS = Y_tensor.shape[1]    # Number of assets (e.g., 7)

print(f"Input Features: {N_FEATURES}, Output Assets: {N_ASSETS}")

# Initialize model with LSTM predictor (after N_FEATURES and N_ASSETS are defined)
model = PortfolioPredictorLSTM(N_FEATURES, N_ASSETS)
print("Model initialized: LSTM-based Portfolio Predictor")

# --- NEW ROBUST SPO DECISION LOSS FUNCTION ---
# NOTE: This is still conceptual/pseudo-code, but it correctly integrates 
# the terms that define your robust decision-making goal.

def robust_spo_decision_loss(mu_predicted, mu_realized, w_old, alpha=0.05):
    """
    Calculates the Robust SPO Loss combining Mean-CVaR and Turnover Penalty.
    
    Args:
        mu_predicted (Tensor): Predicted returns (mu_hat).
        mu_realized (Tensor): True realized returns (mu_true) for that day.
        w_old (Tensor): Portfolio weights from the previous day (w_t-1).
        alpha (float): Confidence level for CVaR (e.g., 5% worst cases).
    """
    
    # ------------------------------------------------------------------------
    # 1. OPTIMIZATION LAYER (CONCEPTUAL MEAN-CVAR + TURNOVER)
    # ------------------------------------------------------------------------
    
    # The solver uses mu_predicted, the assets' historical data (for CVaR), and w_old (for turnover)
    # w_optimal = Solve_MeanCVaR_Differentiable(mu_predicted, w_old, alpha) 
    
    # Placeholder for w_optimal (Breaks backpropagation, but defines the structure):
    N_ASSETS_local = mu_predicted.shape[0]
    w_optimal = torch.ones_like(mu_predicted) / N_ASSETS_local 
    
    # ------------------------------------------------------------------------
    # 2. EVALUATION (MEASURING REALIZED PERFORMANCE)
    # ------------------------------------------------------------------------
    
    # --- Term 1: Realized Return (R_p) ---
    realized_portfolio_return = torch.sum(w_optimal * mu_realized)
    
    # --- Term 2: Realized Turnover (T) ---
    # Measures the cost of moving from the old portfolio (w_old) to the new one (w_optimal)
    # This requires passing the previous day's weight (w_old) into the loss function.
    realized_turnover = torch.sum(torch.abs(w_optimal - w_old))
    
    # --- Term 3: Realized CVaR (C) ---
    # NOTE: Calculating CVaR on a single day's realized return is complex. 
    # Usually, CVaR is estimated over a historical window or model distribution.
    # We will use the negative return as a proxy for loss for simplicity here.
    
    # For a simplified loss, we combine R_p and T with user-defined penalties:
    
    # Hyperparameters for control (needs tuning)
    lambda_risk = 5.0    # Penalty multiplier for Risk/Return
    lambda_turnover = 0.5 # Penalty multiplier for Turnover
    
    # DECISION LOSS: Penalize low returns and high turnover
    decision_loss = - (realized_portfolio_return * lambda_risk) + (realized_turnover * lambda_turnover)
    
    return decision_loss

# --- Training Setup ---
optimizer = optim.Adam(model.parameters(), lr=0.001)
N_EPOCHS = 10

# --- Training Loop ---
for epoch in range(N_EPOCHS):
    total_loss = 0.0
    
    # Assume training is done on the full batch for simplicity (batch size = all data)
    
    # 1. Forward Pass
    mu_predicted = model(X_tensor)
    
    # 2. Calculate Robust SPO Loss with CVaR and Turnover Penalty
    # We iterate over each day (t) in the dataset
    # Initialize previous day's weights (w_old) - for first day, use equal weights
    w_old = torch.ones(N_ASSETS, dtype=torch.float32) / N_ASSETS
    
    loss = torch.tensor(0.0, dtype=torch.float32, requires_grad=True)
    for t in range(mu_predicted.shape[0]):
        # Calculate loss for day t using robust SPO decision loss
        loss = loss + robust_spo_decision_loss(
            mu_predicted[t],             # Model's prediction for day t+1
            Y_tensor[t],                 # True realized returns for day t+1
            w_old,                       # Previous day's portfolio weights
            alpha=0.05                   # CVaR confidence level (5% worst cases)
        )
    
    avg_loss = loss / float(mu_predicted.shape[0])
    
    # 3. Backward Pass (Backpropagation)
    optimizer.zero_grad()
    avg_loss.backward()  # Error flows back through the network
    optimizer.step()     # Weights are updated based on the Robust SPO Loss gradient
    
    total_loss += avg_loss.item()
    
    print(f"Epoch [{epoch+1}/{N_EPOCHS}], Loss: {total_loss:.6f}")

print("\n--- Training Complete ---")
print("The model has now learned to predict returns that minimize the robust portfolio loss")
print("(combining Mean-CVaR risk management and Turnover penalty).")
